\n# Plan: RQ-0028 - Implement Automated Log Parsing Error Search\n\n## Overview\nAdd a health check feature that identifies log parsing errors in Splunk's `_internal` logs by executing a specialized search query and returning structured results about parsing issues.\n\n## Files to Create/Modify\n\n### 1. Create `crates/client/src/endpoints/parsing.rs`\n**Purpose**: Low-level endpoint function to execute parsing error health check via search job.\n\n**Implementation Details**:\n- Define `PARSING_ERROR_SEARCH_QUERY` constant with SPL:\n  ```spl\n  search index=_internal (component=TuningParser OR component=DateParserVerbose OR component=Parser) NOT message=\"parsing fully\" | table _time source sourcetype message log_level component | head 1000\n  ```\n- Implement `check_log_parsing_health(client, base_url, auth_token, max_retries)`:\n  - Uses existing search job infrastructure from `search.rs`\n  - Calls `create_job()` with the specialized query and `earliest_time=\"-24h\"` (last 24 hours)\n  - Calls `wait_for_job()` with appropriate timeout\n  - Calls `get_results()` to fetch results\n  - Parses JSON results into `Vec<LogParsingError>` structs\n  - Returns `Result<LogParsingHealth>`\n\n### 2. Modify `crates/client/src/models.rs`\n**Purpose**: Add data structures for parsing error results.\n\n**Add structs** (after existing health-related models):\n```rust\n/// A single log parsing error entry.\n#[derive(Debug, Deserialize, Clone, Serialize)]\npub struct LogParsingError {\n    #[serde(rename = \"_time\")]\n    pub time: String,\n    pub source: String,\n    pub sourcetype: String,\n    pub message: String,\n    #[serde(default)]\n    pub log_level: String,\n    #[serde(default)]\n    pub component: String,\n}\n\n/// Health check result for log parsing errors.\n#[derive(Debug, Deserialize, Clone, Serialize)]\npub struct LogParsingHealth {\n    pub is_healthy: bool,\n    pub total_errors: usize,\n    pub errors: Vec<LogParsingError>,\n    pub time_window: String,\n}\n```\n\n### 3. Modify `crates/client/src/endpoints/mod.rs`\n**Changes**:\n- Add `mod parsing;`\n- Add `pub use parsing::check_log_parsing_health;`\n\n### 4. Modify `crates/client/src/client.rs`\n**Purpose**: Expose the parsing health check as a convenience method on `SplunkClient`.\n\n**Implementation Details**:\n- Add `use crate::models::{LogParsingHealth, /* existing */};` to imports\n- Add method following the existing pattern (same as `get_license_usage`, `get_kvstore_status`):\n  ```rust\n  pub async fn check_log_parsing_health(&mut self) -> Result<LogParsingHealth> {\n      let auth_token = self.get_auth_token().await?;\n      let result = endpoints::check_log_parsing_health(\n          &self.http,\n          &self.base_url,\n          &auth_token,\n          self.max_retries,\n      ).await;\n      \n      // Standard session retry on 401/403 for session auth\n      match result {\n          Ok(health) => Ok(health),\n          Err(ClientError::ApiError { status, .. })\n              if (status == 401 || status == 403) && !self.is_api_token_auth() => {\n              self.session_manager.clear_session();\n              let new_token = self.get_auth_token().await?;\n              endpoints::check_log_parsing_health(\n                  &self.http,\n                  &self.base_url,\n                  &new_token,\n                  self.max_retries,\n              ).await\n          }\n          Err(e) => Err(e),\n      }\n  }\n  ```\n\n### 5. Create test fixtures and add integration tests\n\n**Create**: `crates/client/tests/fixtures/parsing/check_health.json`\n- Mock search job response with parsing error results\n\n**Add to** `crates/client/tests/integration_tests.rs`:\n- `async fn test_check_log_parsing_health()` - Tests the endpoint function directly\n- `async fn test_splunk_client_check_log_parsing_health()` - Tests the `SplunkClient` method with session retry\n\n## Testing Strategy\n\n1. **Unit tests in models.rs**: Add `test_deserialize_log_parsing_error` and `test_deserialize_log_parsing_health`\n2. **Integration tests**: Mock search job creation, wait, and results with wiremock\n3. **Verify**: Search query targets correct index/components, results parse correctly, health determination logic works\n\n## Implementation Order\n\n1. Add models to `models.rs`\n2. Create `endpoints/parsing.rs` with endpoint function\n3. Update `endpoints/mod.rs` exports\n4. Add client method to `client.rs`\n5. Add tests and fixtures\n6. Run `make ci` to verify\n\n## Success Criteria\n\n- New `check_log_parsing_health()` method works on `SplunkClient`\n- Returns `LogParsingHealth` with parsed error details\n- Existing search infrastructure is reused (no new HTTP patterns)\n- All tests pass, including `make ci`\n- Session retry logic works for non-API-token auth\n